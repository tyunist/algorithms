#	this program is almost as same as icra2012-plan-generator.py which generates plans using algorithm proposed by prof.Chiu 2012 ICRA paper. 
#	though, it takes a number of inputs from a file and then generates a number of corresponding plans 
# 	each input includes: T and D files (stored in the directory /profiles), starting velocity, target distance, arrival time and velocity; 
#	note that velocities appearing here in form of index numbers; time is in unit form. 
#	And the T, D files must match the files that used for generating plans using dynamic progamming and so on. 
#------------------------------------------------------------#
import os
path = os.getcwd() + '/include/'
import sys
sys.path.insert(0, path)
import numpy as np
import random 
from copy import deepcopy
# import pickle as pickle
import helpers
from __init__ import *
import scipy.ndimage 
# define an error threshold 
RE = 1
# we want to discretize the time and velocity range into smaller values so we use a 
# FINNER_SCALE factor. Smaller FINNER_SCALE is, the finner discretization is and the smaller error in 
# simulated reponses. 
FINNER_SCALE = 0.025 # this is the factor of scaling velocities into finner values 

def print_usage():
	print("Usage:")
	print '--------------------'
	print "\tpython", sys.argv[0], 'plans_by_dynamic_file_name', 'plans_file_name', '\n'
	print 'where plans_by_dynamic_file_name is the file that stores the plans generated by dynamic programming method'
	print ' with .pkl extension(starting velocity, target distance, arrival time and velocity)'
	print '\tplans_file_name is the file that you want to store the corresponding plans'
	print '\n\t by default, it is: ', sys.argv[0], 'plans_by_dynamic.pkl', 'plans_by_bio.pkl'
	print '......continue.......'
	print '--------------------'

def planGenerator(targetDistance, v0_index, vend_index, targetTime, T, D):
	print 'targetDistance, v0_index, vend_index, targetTime:', targetDistance, v0_index, vend_index, targetTime		
	# initialize a plan 
	plan = []
	# now, initialize two variables max_vint and min_vint for later use 
	max_vint_index = int(M/FINNER_SCALE) - 1; 
	min_vint_index = 0; 
	# starting value of vint and distance d  
	vint_index = max_vint_index; 
	d = 0; 
	err_in_distance = targetDistance; # try to minimize this error 
	# iterate to find vint 
	num_iter = 0 
	while num_iter < 1000:
		
		# print 'max_index, min_index and vint_index:', max_vint_index, min_vint_index, vint_index
		t = T[v0_index][vint_index] + T[vint_index][vend_index]
		d = D[v0_index][vint_index] + D[vint_index][vend_index] + (vint_index*VEL_SCALE*FINNER_SCALE)*(targetTime - t)
		if abs(d - targetDistance) <= RE:
			print 'found vint index!', vint_index 
			break
		elif d - targetDistance > 0:
			print 'd =',d,' > targetDistance'
			max_vint_index = deepcopy(vint_index); 
			vint_index = min_vint_index + int((max_vint_index - min_vint_index)/2);
			print 'max_index, min_index and vint_index:', max_vint_index, min_vint_index, vint_index
		else:
			print 'd =',d,' < targetDistance'
			min_vint_index = deepcopy(vint_index);
			vint_index = min_vint_index + int((max_vint_index - min_vint_index)/2);
			print 'max_index, min_index and vint_index:', max_vint_index, min_vint_index, vint_index
		num_iter += 1; 
		print 'iter number', num_iter 
	
	t1 = T[v0_index][vint_index]
	t2 = targetTime - T[vint_index][vend_index] 
	
	# now, change the v_index into the form similar to the input 
	plan = [(0, v0_index*FINNER_SCALE), (t1, vint_index*FINNER_SCALE), (t2, vend_index*FINNER_SCALE), (targetTime, vend_index*FINNER_SCALE)]
	
	err_in_distance = targetDistance - D[v0_index][vint_index] - D[vint_index][vend_index] - (vint_index*VEL_SCALE*FINNER_SCALE)*(t2- t1)
	print 'targetDistance and error in distance:',targetDistance, err_in_distance
	
	return plan 
	
	
	
# def bioGenerator(argv):
	# if len(sys.argv) != 3:
		# print_usage()
		# plans_by_dynamic_file_name = 'plans_by_dynamic.pkl'
		# plans_file_name = 'plans_by_bio.pkl'
	# else:
		# plans_by_dynamic_file_name = sys.argv[1]
		# plans_file_name = sys.argv[2]
def bioGenerator(plans_array):
	Tfile = 'profiles/90STNORMED.csv'
	Dfile = 'profiles/90SDNORMED.csv'
	# read T, D tables 
	D_orig = np.array(helpers.readMatrixFile(Dfile, mode = 0) ) # read in float values 
	T_orig = np.array(helpers.readMatrixFile(Tfile, mode = 0) )
	
	# extend those matrix to make finer tables using bilinear interpolation method. For nearest neighbor/ bilinear/ cubic interpolations, just set order = 0 or 1 or 3 correspondingly. 
	D = scipy.ndimage.zoom(D_orig, int(1/FINNER_SCALE), order = 1 )
	T = scipy.ndimage.zoom(T_orig, int(1/FINNER_SCALE), order = 1 )
	
	helpers.writeMatrixFile(T, 'profiles/90STNORMED_' + str(int(1/FINNER_SCALE)) + '_scaled.csv')
	helpers.writeMatrixFile(D, 'profiles/90SDNORMED_' + str(int(1/FINNER_SCALE)) + '_scaled.csv')
	configurations_array = []
	# extract arrival configurations_array
	for plan in plans_array:
		# reduce off_set time for targetTime 
		configuration = [plan[0][0], plan[0][1], plan[0][2], plan[0][3]]
		# store to configurations_array
		configurations_array.append(configuration)
		print 'configuration:', plan[0]
		print 'plan by dynamic:', plan[1]
	
	# generate plans and save to plans_file_name file 
	plans_by_bio_array = []
	for i in range(len(configurations_array)):
		targetDistance = configurations_array[i][0]
		# v0_index, vend_index must be tranformed to a finner scale to match the new T, D tables 
		v0_index = int(configurations_array[i][1]/FINNER_SCALE)
		vend_index = int(configurations_array[i][2]/FINNER_SCALE)
		targetTime = configurations_array[i][3]
		plan_tail = planGenerator(targetDistance, v0_index, vend_index, targetTime, T, D)
		print 'plan is:', plan_tail
		plan = [configurations_array[i], plan_tail]
		plans_by_bio_array.append(plan)
	
	# test by printing out a plan
	print 'sample plan by bio:', plans_by_bio_array[0] 
	return plans_by_bio_array
			
if __name__ == '__main__':
	plan = [[125,21,12,75], [(0,21),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0),(11,0),(12,0),(13,0),(14,0),(15,0),(16,0),(17,0),(18,0),(19,0),(20,0),(21,0),(22,0),(23,0),(24,0),(25,0),(26,0),(27,0),(28,0),(29,0),(30,0),(31,0),(32,0),(33,0),(34,0),(35,0),(36,0),(37,0),(38,0),(39,0),(40,0),(41,0),(42,0),(43,0),(44,0),(45,0),(46,0),(47,0),(48,0),(49,0),(50,0),(51,0),(52,0),(53,0),(54,0),(55,0),(56,0),(57,0),(58,0),(59,0),(60,0),(61,0),(62,0),(63,0),(64,0),(65,0),(66,0),(67,0),(68,0),(69,0),(70,0),(71,10),(73,15),(74,17),(75,12)]
]
	bioGenerator([plan])
	